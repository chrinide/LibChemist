#!/usr/bin/env python3
"""This script is used to create the experimental data look up tables for the
atom class.

In order to run this script simply needs to know where you want the generated
files to live.


usage:
    python3 generate_atomicinfo.py <output_directory>

"""

#Knobs that you may want to tweak
pm2bohr = 52.917721067

####################### Begin Script #################################


import os
import sys
import re

if len(sys.argv) != 2:
   print("Usage: generate_atomicinfo.py <output_directory>")
   quit(1)


outbase = sys.argv[1]
mypath = os.path.dirname(os.path.realpath(__file__))
datadir = os.path.join(mypath, "data")

atomicinfo = {}

#File containing the names and symbols of the atoms
name_file = os.path.join(datadir, "ElementNames.txt")

#File containing the masses of the atoms
mass_file = os.path.join(datadir, "CIAAW-MASSES.formatted.txt")

#File containing the covalent radii of the atoms
cov_file = os.path.join(datadir,"CovRadii.txt")

#File containing the Van der Waals radii of the atoms
vdw_file = os.path.join(datadir,"VanDerWaalRadius.txt")

#File containing the isotope masses
iso_file = os.path.join(datadir, "CIAAW-ISOTOPEMASSES.formatted.txt")

#File containing the isotope abundances
iso_ab_file = os.path.join(datadir, "CIAAW-ABUNDANCE.formatted.txt")

#File containing the multiplicities of each atom
mult_file = os.path.join(datadir, "NIST-ATOMICION.formatted.txt")

#Read in names and make initial entries
for l in open(name_file).readlines():
    l.strip()
    z, sym, name = l.split()
    z = int(z)

    atomicinfo[z] = { "sym" : sym,
                      "name" : name,
                      "mult": 0,
                      "termsym": "x",
                      "mass": (0.0, 0.0, 0.0),
                      "covradius":0.0,
                      "vdwradius":0.0,
                      "isos" : {}
                    }


# Read in experimental masses
for l in open(mass_file).readlines()[5:]:
  l.strip()
  z, sym, mid, low, high = l.split()
  z = int(z)

  atomicinfo[z]["mass"] = ( mid, low, high )

#Read in Covalent Radii
for l in open(cov_file).readlines()[1:]:
  l.strip()
  z,r,unit=l.split()
  z=int(z)
  r=float(r)
  atomicinfo[z]["covradius"]=r/pm2bohr

#Read in van der waal Radii
for l in open(vdw_file).readlines()[1:]:
  l.strip()
  z,r,unit=l.split()
  z=int(z)
  r=float(r)
  atomicinfo[z]["vdwradius"]=r/pm2bohr


# Read in isotope masses
for l in open(iso_file).readlines()[5:]:
  l.strip()
  z, sym, isonum, mid, low, high = l.split()
  z = int(z)

  if not isonum in atomicinfo[z]["isos"]:
      atomicinfo[z]["isos"][isonum] = { }

  atomicinfo[z]["isos"][isonum]["mass"] = (mid, low, high)


# Read in isotope abundances
for l in open(iso_ab_file).readlines()[5:]:
  l.strip()
  z, sym, isonum, mid, low, high = l.split()
  z = int(z)

  if not isonum in atomicinfo[z]["isos"]:
      atomicinfo[z]["isos"][isonum] = { }

  atomicinfo[z]["isos"][isonum]["abundance"] = (mid, low, high)


# Fill in missing isotope info
for z, atom in atomicinfo.items():
  for isonum, isodat in atom["isos"].items():
    if not "mass" in isodat:
        isodat["mass"] = (isonum, isonum, isonum)
    if not "abundance" in isodat:
        isodat["abundance"] = (0, 0, 0)


# Read in multiplicities
for l in open(mult_file).readlines()[5:]:
  z, occ, mult, termsym = l.split()
  z = int(z)
  atomicinfo[z]["mult"] = int(mult)
  atomicinfo[z]["termsym"] = termsym

header_file = os.path.join(outbase,"AtomicInfo.hpp")
src_file = os.path.join(outbase,"AtomicInfo.cpp")

comment ="""
/** \\file Declares structures containing basic experimental data.
 *
 * \warning This file is automatically generated via generate_atomicinfo.py.
 *    DO NOT EDIT!!!
 */
"""


with open(header_file,'w') as f:

    f.write("#pragma once\n")
    f.write("#include <string>\n")
    f.write("#include <unordered_map>\n")
    f.write("#include <vector>\n")
    f.write(comment+'\n')
    f.write("namespace LibChemist {\n")
    f.write("namespace detail_ {\n\n")
    f.write("struct IsotopeData {\n")
    f.write("    size_t isonum;           //! Isotope number (Z + number of neutrons)\n")
    f.write("    double mass;          //! Mass of the isotope\n")
    f.write("    double mass_low;      //! Lower bound of the isotope mass\n")
    f.write("    double mass_high;     //! Upper bound of the isotope mass\n")
    f.write("    double abund;         //! Natural abundance of the isotope (out of 1)\n")
    f.write("    double abund_low;     //! Lower bound on the isotope's abundance\n")
    f.write("    double abund_high;    //! Upper bound on the isotope's abundance\n")
    f.write("};\n\n")
    f.write("/*! \brief Information about an atom/element */\n")
    f.write("struct AtomicData {\n")
    f.write("    size_t Z;                //! Atomic Z-number (number of protons)\n")
    f.write("    std::string sym;      //! Element's atomic symbol\n")
    f.write("    std::string name;     //! Full name of the element\n")
    f.write("    int multiplicity;     //! Ground-state multiplicity\n")
    f.write("    std::string termsym;  //! Term symbol character\n")
    f.write("    double mass;          //! Mass of the element (isotope masses weighted by abundance)\n")
    f.write("    double mass_low;      //! Lower bound on the mass of the element\n")
    f.write("    double mass_high;     //! Upper bound on the mass of the element\n")
    f.write("    double covradius;     //! Covalent radius in a.u.\n")
    f.write("    double vdwradius;     //! VDW radius in a.u.\n")
    f.write("    std::vector<IsotopeData> isotopes; //!< All isotope information for this atom\n")
    f.write("};\n\n")
    f.write("extern const std::unordered_map<size_t, std::string> Z2sym_;\n\n")
    f.write("extern const std::unordered_map<std::string, size_t> sym2Z_;\n\n")
    f.write("extern const std::unordered_map<size_t, AtomicData> atomic_data_;\n\n")
    f.write("/** \\brief Returns the most common isotope number for the atom with atomic number \p Z\n")
    f.write(" *\n")
    f.write(" * \\param[in] Z The atomic number for which you want the most common isotope\n")
    f.write(" * \\returns The isotope number (protons+neutrons) of the most common isotope\n")
    f.write(" * \\throws std::out_of_range if we do not have data for \p Z\n")
    f.write(" */\n")
    f.write("size_t most_common_isotope(size_t Z);\n\n")
    f.write("/** \\brief Returns the mass of a given isotope number\n")
    f.write(" *\n")
    f.write(" * \\param[in] Z The atomic number of the atom\n")
    f.write(" * \\param[in] isonum The isotope number (protons+neutrons)\n")
    f.write(" * \\returns The mass of the desired isomer, in Daltons\n")
    f.write(" * \\throws std::out_of_range if we do not have data for \p Z or if\n")
    f.write(" *      there is no data for that isotope number.\n")
    f.write(" */\n")
    f.write("double isotope_mass(size_t Z, size_t isonum);\n\n")
    f.write("}}//End namespaces\n")

with open(src_file,'w') as f:
    f.write("#include \"LibChemist/lut/AtomicInfo.hpp\"\n")
    f.write("#include <algorithm>\n\n")
    f.write("namespace LibChemist {\n")
    f.write("namespace detail_ {\n")

    # First, atomic Z to symbol map
    f.write("extern const std::unordered_map<size_t, std::string> Z2sym_{\n")
    for k,v in sorted(atomicinfo.items()):
        f.write("  {{ {} , \"{}\" }},\n".format(k, v["sym"]))
    f.write("}; // close Z2sym_\n\n\n")

    # Next, atomic symbol to Z
    f.write("extern const std::unordered_map<std::string, size_t> sym2Z_{\n")
    for k,v in sorted(atomicinfo.items()):
        f.write("  {{ \"{}\" , {} }},\n".format(v["sym"], k))
    f.write("}; // close sym2Z_\n\n\n")

    # Next, full atomic data
    f.write("extern const std::unordered_map<size_t, AtomicData> atomic_data_{\n")
    for k,v in sorted(atomicinfo.items()):
        f.write("  {{ {:<4} , {{ {},\n".format(k, k))
        f.write("             \"{}\",\n".format(v["sym"]))
        f.write("             \"{}\",\n".format(v["name"]))
        f.write("             {},\n".format(v["mult"]))
        f.write("             \"{}\",\n".format(v["termsym"]))
        f.write("             {},\n".format(v["mass"][0]))
        f.write("             {},\n".format(v["mass"][1]))
        f.write("             {},\n".format(v["mass"][2]))
        f.write("             {},\n".format(v["covradius"]))
        f.write("             {},\n".format(v["vdwradius"]))
        # isotope info
        f.write("              {\n")
        for ki,vi in sorted(v["isos"].items()):
            f.write("                 {{ {}, {}, {}, {}, {}, {}, {} }},\n".
                format(ki,vi["mass"][0],vi["mass"][1],vi["mass"][2],
                       vi["abundance"][0], vi["abundance"][1],
                       vi["abundance"][2]
                )
            )
        f.write("              },\n")  # Closes isotope vector
        f.write("           },\n")  # Closes atomic data
        f.write("  },\n\n")  # closes map pair
    f.write("}; // close atomic_Z_data_\n\n")
    f.write("size_t most_common_isotope(size_t Z){\n")
    f.write("  const auto& ad=atomic_data_.at(Z);\n")
    f.write("  auto maxit = std::max_element(\n")
    f.write("      ad.isotopes.begin(), ad.isotopes.end(),\n")
    f.write("      [](const IsotopeData & idat1, const IsotopeData & idat2)\n")
    f.write("      { return idat1.abund < idat2.abund; });\n")
    f.write("  return maxit->isonum;\n}\n\n")
    f.write("double isotope_mass(size_t Z, size_t isonum){\n")
    f.write("  const auto& ad=atomic_data_.at(Z);\n")
    f.write("  for(const auto& x: ad.isotopes)\n")
    f.write("     if(x.isonum==isonum)return x.mass;\n")
    f.write("   throw std::out_of_range(\"Isotope number is not in range\");\n}\n\n")
    f.write("}}//End namespaces\n")





